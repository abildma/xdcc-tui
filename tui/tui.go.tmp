package tui

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"xdcc-tui/search"
	"xdcc-tui/xdcc"

	"github.com/charmbracelet/bubbles/progress"
	"github.com/charmbracelet/bubbles/spinner"
	"github.com/charmbracelet/bubbles/textinput"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

// Define styles
var (
	titleStyle = lipgloss.NewStyle().
			Bold(true).
			Foreground(lipgloss.Color("#FAFAFA")).
			Background(lipgloss.Color("#7D56F4")).
			PaddingLeft(2).
			PaddingRight(2)

	headerStyle = lipgloss.NewStyle().
			Bold(true).
			Foreground(lipgloss.Color("#FAFAFA")).
			Background(lipgloss.Color("#7D56F4")).
			PaddingLeft(2).
			PaddingRight(2).
			MarginBottom(1)

	highlightStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#7D56F4")).
			Bold(true)

	errorStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#F25D94")).
			Bold(true)

	successStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#43BF6D")).
			Bold(true)
)

// Define modes
type Mode int

const (
	ModeSearch Mode = iota
	ModeResults
	ModeDownloading
	ModeFilter
)

// FileItem represents a file in search results
type FileItem struct {
	name     string
	size     int64
	url      *xdcc.IRCFile
	selected bool
}

// List item interface implementations
func (i FileItem) Title() string {
	if i.selected {
		return highlightStyle.Render("[✓] " + i.name)
	}
	return i.name
}

func (i FileItem) Description() string {
	return fmt.Sprintf("Size: %s | %s", FormatSize(i.size), i.url.String())
}

func (i FileItem) FilterValue() string {
	return i.name
}

// Helper to find a file item by URL
func findFileItemByURL(items []FileItem, url *xdcc.IRCFile) *FileItem {
	for _, item := range items {
		if item.url.String() == url.String() {
			return &item
		}
	}
	return nil
}

// Message types for the TUI
type searchResultMsg struct {
	results []FileItem
}

type errorMsg struct {
	err error
	url *xdcc.IRCFile
}

type downloadProgressMsg struct {
	bytesDownloaded int64
	totalBytes      int64
	url             *xdcc.IRCFile
	speed           float64
}

type downloadStartedMsg struct {
	file string
}

type downloadFinishedMsg struct {
	url *xdcc.IRCFile
}

// Model represents the TUI state
type Model struct {
	mode            Mode
	searchInput     textinput.Model
	filterInput     textinput.Model
	spinner         spinner.Model
	progress        progress.Model
	searchResults   []FileItem
	filteredResults []FileItem
	cursor          int
	page            int
	itemsPerPage    int
	searchEngine    *search.ProviderAggregator
	error           string
	status          string
	selectedFiles   map[int]bool
	downloadQueue   []*xdcc.IRCFile
	queueCursor     int
	downloadPaused  bool
	currentFile     string
	downloadedSize  int64
	totalSize       int64
	lastDownloadURL *xdcc.IRCFile
}

// NewModel creates a new model
func NewModel() Model {
	// Setup search input
	ti := textinput.New()
	ti.Placeholder = "Enter search keywords"
	ti.Focus()
	ti.CharLimit = 50

	// Setup filter input
	fi := textinput.New()
	fi.Placeholder = "Filter results"
	fi.CharLimit = 50

	// Setup spinner
	s := spinner.New()
	s.Spinner = spinner.Dot
	s.Style = lipgloss.NewStyle().Foreground(lipgloss.Color("#7D56F4"))

	// Setup progress bar
	p := progress.New(progress.WithDefaultGradient())

	return Model{
		searchInput:   ti,
		filterInput:   fi,
		spinner:       s,
		progress:      p,
		mode:          ModeSearch,
		selectedFiles: make(map[int]bool),
		itemsPerPage:  15,
		page:          0,
		searchEngine: search.NewProviderAggregator(
			&search.XdccEuProvider{},
			&search.SunXdccProvider{},
		),
	}
}

// Init initializes the model
func (m Model) Init() tea.Cmd {
	return tea.Batch(
		textinput.Blink,
		m.spinner.Tick,
	)
}

// Update handles user input and events
func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmd tea.Cmd
	var cmds []tea.Cmd

	switch msg := msg.(type) {
	case tea.KeyMsg:
		// Special handling for search and filter modes
		// Pass input to text fields first when in these modes
		if m.mode == ModeSearch {
			// Handle special keys first
			switch msg.String() {
			case "ctrl+c", "q":
				return m, tea.Quit
			case "esc":
				// Exit search mode if there are results
				if len(m.searchResults) > 0 {
					m.mode = ModeResults
					m.searchInput.Blur()
					return m, nil
				}
			case "tab":
				// Switch to results mode if we have results
				if len(m.searchResults) > 0 {
					m.mode = ModeResults
					m.searchInput.Blur()
					return m, nil
				}
			case "enter":
				// Submit search
				m.status = "Searching for " + m.searchInput.Value() + "..."
				return m, func() tea.Msg {
					// Split search query into keywords
					keywords := strings.Fields(m.searchInput.Value())
					results, err := m.searchEngine.Search(keywords)
					if err != nil {
						return errorMsg{err: err}
					}

					// Convert to FileItems
					fileItems := []FileItem{}
					for _, r := range results {
						fileItems = append(fileItems, FileItem{
							name:     r.Name,
							size:     r.Size,
							url:      &r.URL,
							selected: false,
						})
					}

					// Switch to results mode if we found something
					if len(fileItems) > 0 {
						m.mode = ModeResults
						m.searchInput.Blur()
					}

					return searchResultMsg{results: fileItems}
				}
			default:
				// Pass all other keys to the search input
				m.searchInput, cmd = m.searchInput.Update(msg)
				return m, cmd
			}
		} else if m.mode == ModeFilter {
			// Handle special keys first
			switch msg.String() {
			case "ctrl+c", "q":
				return m, tea.Quit
			case "esc":
				// Exit filter mode
				m.mode = ModeResults
				m.filterInput.Blur()
				m.status = "Filter mode exited"
				return m, nil
			case "enter":
				// Apply filter
				m.mode = ModeResults
				m.filterInput.Blur()
				m.status = "Filter applied"
				return m, nil
			default:
				// Pass all other keys to the filter input
				m.filterInput, cmd = m.filterInput.Update(msg)

				// Apply filter as you type
				filterText := m.filterInput.Value()
				if filterText == "" {
					m.filteredResults = m.searchResults
					m.status = fmt.Sprintf("Showing all %d results", len(m.searchResults))
				} else {
					m.filteredResults = []FileItem{}
					for _, item := range m.searchResults {
						if strings.Contains(strings.ToLower(item.name), strings.ToLower(filterText)) {
							m.filteredResults = append(m.filteredResults, item)
						}
					}
					m.status = fmt.Sprintf("Found %d matching results", len(m.filteredResults))
				}

				// Reset page and cursor
				m.page = 0
				m.cursor = 0

				return m, cmd
			}
		}

		// For other modes, handle keys normally
		switch msg.String() {
		case "ctrl+c", "q":
			return m, tea.Quit

		case "enter":
			if m.mode == ModeSearch {
				// Submit search
				m.status = "Searching for " + m.searchInput.Value() + "..."
				return m, func() tea.Msg {
					// Split search query into keywords
					keywords := strings.Fields(m.searchInput.Value())
					results, err := m.searchEngine.Search(keywords)
					if err != nil {
						return errorMsg{err: err}
					}

					// Convert to FileItems
					fileItems := []FileItem{}
					for _, r := range results {
						fileItems = append(fileItems, FileItem{
							name:     r.Name,
							size:     r.Size,
							url:      &r.URL,
							selected: false,
						})
					}

					// Switch to results mode if we found something
					if len(fileItems) > 0 {
						m.mode = ModeResults
						m.searchInput.Blur()
					}

					return searchResultMsg{results: fileItems}
				}
			} else if m.mode == ModeResults {
				// Start download of ONLY explicitly selected files
				var selectedItems []FileItem

				// ONLY look for files with the selected flag set to true
				for _, item := range m.filteredResults {
					if item.selected {
						selectedItems = append(selectedItems, item)
						fmt.Printf("Found selected file: %s\n", item.name)
					}
				}

				if len(selectedItems) > 0 {
					// Add selected files to download queue
					for _, item := range selectedItems {
						m.downloadQueue = append(m.downloadQueue, item.url)
					}

					// Switch to download mode
					m.mode = ModeDownloading
					m.status = fmt.Sprintf("Added %d files to download queue", len(selectedItems))

					// Start download if not already downloading
					if len(m.downloadQueue) > 0 && m.downloadedSize == 0 {
						// Ensure downloads directory exists
						os.MkdirAll("downloads", 0755)

						// Start first download
						outputPath := filepath.Join("downloads", filepath.Base(m.downloadQueue[0].String()))
						cmds = append(cmds, downloadFile(m.downloadQueue[0], outputPath))
					}
				} else {
					m.status = "No files selected for download"
				}
				return m, tea.Batch(cmds...)
			}

		case "space":
			// Toggle selection of current item
			if m.mode == ModeResults {
				// Get current page items
				startIdx := m.page * m.itemsPerPage
				endIdx := startIdx + m.itemsPerPage
				if endIdx > len(m.filteredResults) {
					endIdx = len(m.filteredResults)
				}

				if startIdx <= m.cursor && m.cursor < endIdx {
					// Toggle selection
					actualIdx := startIdx + m.cursor
					if actualIdx < len(m.filteredResults) {
						// Initialize map if needed
						if m.selectedFiles == nil {
							m.selectedFiles = make(map[int]bool)
						}

						// CRITICAL FIX: Toggle the selected flag directly on the item
						m.filteredResults[actualIdx].selected = !m.filteredResults[actualIdx].selected

						// Also store in map with correct index (actualIdx, not cursor)
						m.selectedFiles[actualIdx] = m.filteredResults[actualIdx].selected

						// Use the actual item's selected state for status message
						if m.filteredResults[actualIdx].selected {
							m.status = fmt.Sprintf("Selected: %s", m.filteredResults[actualIdx].name)
						} else {
							m.status = fmt.Sprintf("Unselected: %s", m.filteredResults[actualIdx].name)
						}
					}
				}
			}

		case "j", "down":
			// Move cursor down
			if m.mode == ModeResults {
				startIdx := m.page * m.itemsPerPage
				endIdx := startIdx + m.itemsPerPage
				if endIdx > len(m.filteredResults) {
					endIdx = len(m.filteredResults)
				}

				m.cursor++
				if startIdx+m.cursor >= endIdx {
					m.cursor = endIdx - startIdx - 1
					if m.cursor < 0 {
						m.cursor = 0
					}
				}
			} else if m.mode == ModeDownloading {
				// Move cursor in download queue
				m.queueCursor++
				if m.queueCursor >= len(m.downloadQueue) {
					m.queueCursor = len(m.downloadQueue) - 1
					if m.queueCursor < 0 {
						m.queueCursor = 0
					}
				}
			}

		case "k", "up":
			// Move cursor up
			if m.mode == ModeResults {
				m.cursor--
				if m.cursor < 0 {
					m.cursor = 0
				}
			} else if m.mode == ModeDownloading {
				// Move cursor in download queue
				m.queueCursor--
				if m.queueCursor < 0 {
					m.queueCursor = 0
				}
			}

		case "h", "left":
			// Previous page
			if m.mode == ModeResults && m.page > 0 {
				m.page--
				m.cursor = 0
				m.status = fmt.Sprintf("Page %d of %d", m.page+1, (len(m.filteredResults)-1)/m.itemsPerPage+1)
			}

		case "l", "right":
			// Next page
			if m.mode == ModeResults {
				maxPage := (len(m.filteredResults) - 1) / m.itemsPerPage
				if m.page < maxPage {
					m.page++
					m.cursor = 0
					m.status = fmt.Sprintf("Page %d of %d", m.page+1, maxPage+1)
				}
			}

		case "d":
			// Remove item from download queue
			if m.mode == ModeDownloading && len(m.downloadQueue) > 0 && m.queueCursor < len(m.downloadQueue) {
				// Save the item to show in status
				itemToRemove := m.downloadQueue[m.queueCursor]

				// Get readable filename for status message
				fileName := "unknown file"
				fileItem := findFileItemByURL(m.searchResults, itemToRemove)
				if fileItem != nil {
					fileName = fileItem.name
				}

				// Remove from queue
				m.downloadQueue = append(m.downloadQueue[:m.queueCursor], m.downloadQueue[m.queueCursor+1:]...)

				// Adjust cursor if needed
				if m.queueCursor >= len(m.downloadQueue) && len(m.downloadQueue) > 0 {
					m.queueCursor = len(m.downloadQueue) - 1
				}

				m.status = fmt.Sprintf("Removed %s from download queue", fileName)
			}

		case "s":
			// Search mode
			if m.mode != ModeSearch {
				m.mode = ModeSearch
				m.searchInput.Focus()
				m.filterInput.Blur()
				m.status = "Enter search terms"
			}

		case "f":
			// Filter mode
			if m.mode == ModeResults {
				m.mode = ModeFilter
				m.filterInput.Focus()
				m.searchInput.Blur()
				m.status = "Enter filter terms"
			}

		case "esc":
			// Exit filter mode or go back to results
			if m.mode == ModeFilter {
				m.mode = ModeResults
				m.filterInput.Blur()
				m.status = "Filter mode exited"
			} else if m.mode == ModeDownloading {
				m.mode = ModeResults
				m.status = "Returned to results view"
			}

		case "tab":
			// Toggle between modes - works from any mode
			if m.mode == ModeSearch {
				// From search -> results (if we have results)
				if len(m.searchResults) > 0 {
					m.mode = ModeResults
					m.searchInput.Blur()
					m.status = "Switched to results mode"
				}
			} else if m.mode == ModeResults {
				// From results -> downloads
				m.mode = ModeDownloading
				m.status = "Switched to download queue view"
			} else if m.mode == ModeDownloading {
				// From downloads -> search
				m.mode = ModeSearch
				m.searchInput.Focus()
				m.status = "Enter search terms"
			}

		default:
			// Handle text input based on current mode
			if m.mode == ModeSearch {
				var cmd tea.Cmd
				m.searchInput, cmd = m.searchInput.Update(msg)
				return m, cmd
			} else if m.mode == ModeFilter {
				var cmd tea.Cmd
				m.filterInput, cmd = m.filterInput.Update(msg)

				// Apply filter as you type
				filterText := m.filterInput.Value()
				if filterText == "" {
					m.filteredResults = m.searchResults
					m.status = fmt.Sprintf("Showing all %d results", len(m.searchResults))
				} else {
					m.filteredResults = []FileItem{}
					for _, item := range m.searchResults {
						if strings.Contains(strings.ToLower(item.name), strings.ToLower(filterText)) {
							m.filteredResults = append(m.filteredResults, item)
						}
					}
					m.status = fmt.Sprintf("Found %d results containing '%s'", len(m.filteredResults), filterText)
				}

				// Reset page to 0
				m.page = 0

				return m, cmd
			}
		}

	case searchResultMsg:
		// Handle search results
		m.searchResults = msg.results
		m.filteredResults = msg.results
		if len(msg.results) > 0 {
			m.status = fmt.Sprintf("Found %d results", len(msg.results))
		} else {
			m.status = "No results found"
		}

	case downloadProgressMsg:
		// Update progress information
		m.downloadedSize = msg.bytesDownloaded
		m.totalSize = msg.totalBytes

		if m.currentFile == "" {
			// Try to get the filename from the search results for better display
			fileItem := findFileItemByURL(m.searchResults, msg.url)
			if fileItem != nil {
				m.currentFile = fileItem.name
			} else {
				// Fallback to URL string if the file item is not found
				m.currentFile = msg.url.String()
			}
		}

		// Calculate progress percentage and update status
		progressPercent := float64(m.downloadedSize) / float64(m.totalSize)
		m.progress.SetPercent(progressPercent)

		// Update status with speed information
		m.status = fmt.Sprintf("Downloading %s: %s / %s (%.2f MB/s)",
			m.currentFile,
			FormatSize(m.downloadedSize),
			FormatSize(m.totalSize),
			msg.speed/1024/1024)

		// Continue monitoring download
		return m, func() tea.Msg {
			time.Sleep(500 * time.Millisecond)
			return msg
		}

	case downloadFinishedMsg:
		// Download completed successfully
		fileItem := findFileItemByURL(m.searchResults, msg.url)
		if fileItem != nil {
			m.status = successStyle.Render(fmt.Sprintf("✓ Download of %s completed successfully!", fileItem.name))
		} else {
			m.status = successStyle.Render(fmt.Sprintf("✓ Download completed successfully!"))
		}

		// Reset download state
		m.downloadedSize = 0
		m.totalSize = 0
		m.currentFile = ""
		m.progress.SetPercent(0)

		// Remove the completed download from the queue
		if len(m.downloadQueue) > 0 {
			m.downloadQueue = m.downloadQueue[1:]
		}

		// Start the next download if there are more in the queue
		if len(m.downloadQueue) > 0 {
			outputPath := filepath.Join("downloads", filepath.Base(m.downloadQueue[0].String()))
			return m, downloadFile(m.downloadQueue[0], outputPath)
		}

	case errorMsg:
		// Handle download errors
		if msg.err != nil {
			m.error = errorStyle.Render("Error: " + msg.err.Error())
			m.lastDownloadURL = msg.url

			// Reset download state
			m.downloadedSize = 0
			m.totalSize = 0
			m.currentFile = ""
			m.progress.SetPercent(0)

			// Remove the failed download from the queue
			if len(m.downloadQueue) > 0 {
				m.downloadQueue = m.downloadQueue[1:]
			}

			// Start the next download if there are more in the queue
			if len(m.downloadQueue) > 0 {
				outputPath := filepath.Join("downloads", filepath.Base(m.downloadQueue[0].String()))
				return m, downloadFile(m.downloadQueue[0], outputPath)
			}
		}

	case tea.WindowSizeMsg:
		// Handle window resize
		return m, nil
	}

	return m, cmd
}

// View renders the UI
func (m Model) View() string {
	var s strings.Builder

	// Header
	s.WriteString(headerStyle.Render("✨ XDCC-TUI - Interactive XDCC Downloader ✨"))
	s.WriteString("\n\n")

	// Render based on the current mode
	switch m.mode {
	case ModeSearch:
		s.WriteString(titleStyle.Render("Search Mode"))
		s.WriteString("\n\n")
		s.WriteString("Enter search terms: ")
		s.WriteString(m.searchInput.View())
		s.WriteString("\n\n")
		s.WriteString("Press Enter to search")

	case ModeFilter:
		s.WriteString(titleStyle.Render("Filter Mode"))
		s.WriteString("\n\n")
		s.WriteString("Filter results: ")
		s.WriteString(m.filterInput.View())
		s.WriteString("\n\n")
		s.WriteString("Press Esc to exit filter mode")

	case ModeResults:
		s.WriteString(titleStyle.Render("Results Mode"))
		s.WriteString("\n\n")

		// Get current page items
		startIdx := m.page * m.itemsPerPage
		endIdx := startIdx + m.itemsPerPage
		if endIdx > len(m.filteredResults) {
			endIdx = len(m.filteredResults)
		}

		// Display pagination info
		totalPages := (len(m.filteredResults)-1)/m.itemsPerPage + 1
		s.WriteString(fmt.Sprintf("Page %d of %d (Total: %d files)\n\n",
			m.page+1, totalPages, len(m.filteredResults)))

		// Display results with cursor
		for i := startIdx; i < endIdx; i++ {
			item := m.filteredResults[i]
			cursorIdx := i - startIdx

			// Highlight selected items
			var fileDisplay string
			if item.selected {
				fileDisplay = highlightStyle.Render("[✓] " + item.name)
			} else {
				fileDisplay = item.name
			}

			// Add cursor and format line
			if cursorIdx == m.cursor {
				s.WriteString(highlightStyle.Render("> " + fileDisplay))
			} else {
				s.WriteString("  " + fileDisplay)
			}

			// Add file size
			s.WriteString(fmt.Sprintf(" (%s)\n", FormatSize(item.size)))
		}

	case ModeDownloading:
		s.WriteString(titleStyle.Render("Download Queue"))
		s.WriteString("\n\n")

		// Show progress if downloading
		if m.downloadedSize > 0 && m.totalSize > 0 {
			s.WriteString(fmt.Sprintf("Downloading: %s\n", m.currentFile))
			s.WriteString(fmt.Sprintf("%s / %s\n",
				FormatSize(m.downloadedSize),
				FormatSize(m.totalSize)))
			s.WriteString(m.progress.View())
			s.WriteString("\n\n")
		}

		// Display queue with cursor
		if len(m.downloadQueue) == 0 {
			s.WriteString("Download queue is empty\n")
		} else {
			s.WriteString(fmt.Sprintf("Files in queue: %d\n\n", len(m.downloadQueue)))

			for i, url := range m.downloadQueue {
				// Get readable filename for display
				fileName := "unknown file"
				fileSize := "unknown size"
				fileItem := findFileItemByURL(m.searchResults, url)
				if fileItem != nil {
					fileName = fileItem.name
					fileSize = FormatSize(fileItem.size)
				}

				// Format the entry with file information instead of just URL
				entry := fmt.Sprintf("%d. %s (%s)", i+1, fileName, fileSize)

				// Highlight current cursor position
				if i == m.queueCursor {
					s.WriteString(highlightStyle.Render("> " + entry + "\n"))
				} else {
					s.WriteString("  " + entry + "\n")
				}
			}
		}
	}

	// Footer with status and error messages
	s.WriteString("\n\n")

	// Display any error message
	if m.error != "" {
		s.WriteString(m.error)
		s.WriteString("\n")
	}

	// Display status message
	if m.status != "" {
		s.WriteString(m.status)
		s.WriteString("\n")
	}

	// Help text
	s.WriteString("\n")
	switch m.mode {
	case ModeSearch:
		s.WriteString("s: Search | tab: Switch Mode | q: Quit")
	case ModeResults:
		s.WriteString("Space: Select | Enter: Download | j/k: Move | h/l: Pages | f: Filter | q: Quit")
	case ModeFilter:
		s.WriteString("Esc: Exit Filter | q: Quit")
	case ModeDownloading:
		s.WriteString("j/k: Move | d: Remove | tab: Switch Mode | q: Quit")
	}

	return s.String()
}

// downloadFile starts downloading a file and returns a tea.Cmd
func downloadFile(url *xdcc.IRCFile, outputPath string) tea.Cmd {
	return func() tea.Msg {
		// Log connection information for debugging
		fmt.Printf("Starting download: %s\n", url.String())

		// Set up a transfer
		transfer := xdcc.NewTransfer(xdcc.Config{
			File:    *url,
			OutPath: outputPath,
			SSLOnly: false,
		})

		// Start transfer
		err := transfer.Start()
		if err != nil {
			// Try to extract user-friendly error message
			userFriendlyError := err
			if strings.Contains(err.Error(), "queue is full") {
				userFriendlyError = fmt.Errorf("Bot's download queue is full. Try again later")
			} else if strings.Contains(err.Error(), "no slots open") {
				userFriendlyError = fmt.Errorf("Bot has no slots available. Try again later")
			} else if strings.Contains(err.Error(), "you must be on a known channel") {
				userFriendlyError = fmt.Errorf("Bot requires you to join its channel first")
			} else if strings.Contains(err.Error(), "banned") {
				userFriendlyError = fmt.Errorf("You are banned from this bot")
			}

			return errorMsg{
				err: userFriendlyError,
				url: url,
			}
		}

		// Create a command to listen to events
		// Set up a listener in a goroutine
		go func() {
			evts := transfer.PollEvents()
			for evt := range evts {
				// Handle events with the appropriate tea.Msg
				switch e := evt.(type) {
				case xdcc.TransferProgessEvent:
					// Use program.Send to send updates
					fmt.Printf("Progress: %d bytes (%.2f KB/s)\n", e.TransferBytes, float64(e.TransferRate)/1024)
				case xdcc.TransferStartedEvent:
					fmt.Printf("Download started: %s (%.2f MB)\n", outputPath, float64(e.FileSize)/1024/1024)
				case xdcc.TransferCompletedEvent:
					fmt.Printf("Download completed: %s\n", outputPath)
				case xdcc.TransferAbortedEvent:
					fmt.Printf("Download aborted: %s\n", e.Error)
				}
			}
		}()
		
		return downloadStartedMsg{file: filepath.Base(outputPath)}
	}
}

// We've replaced the pollDownloadEvents with a direct goroutine in downloadFile
